### 1. string과 StringBuild의 차이점에 대해서 설명해주세요. 난이도 ★☆☆☆☆

```
기본적인 차이는 String은 immutable(불변함), StringBuffer는 mutable(변함,변하기쉬움)

string 타입은 불변 객체이기 때문에 string에 대한 모든 변환은
새로운 메모리 할당을 발생시킨다.
```

### 2. using 이라는 키워드는 네임스페이스를 링크하기 위해서 사용하기도 하지만 객체를 생성할 때 또한 사용되기도 합니다. 이때 using을 이용하는 목적에 대해서 설명해주세요. 난이도 ★★☆☆☆

```
try/finally를 대신하는 using 예약어를 제공한다.

using (FileLogger Log = new FileLogger("sample.log"))
{

log.Write("Start");

log.Write("End");

}

using은 괄호 안에서 생성된 객체의 Dispose 메서드를 블록이 끝나는 시점에
자동으로 호출하는 역할을 한다.

즉, using 예약어는 try/finaly/Dispose 에 대한 간편 표기법에 해당된다.
```

### 3. C# 2.0에서는 델리게이트를 쉽게 등록하는 문법적 편의를 위해서 익명 메서드라는 문법을 제공했습니다. 그리고 C#3.0에는 이 익명 메서드를 더 쉽게 사용할 수 있게 하기 위해서 람다식이라는 문법이 등장하게 됩니다. 그렇다면 익명메서드와 람다식 구문을 사용하는 코드를 작성해주세요. 난이도 ★★★☆☆


```
익명 메서드(anonymous method)란 단어 그대로 이름이 없는 메서드로서 델리게이트에 전달되는 메서드가 일회성으로만 필요할 때 편의상 사용한다.



예) 익명 메서드 사용

static void main(string[ ] args)
{
  Thread thread = new Thread(
    delegate(object obj)
    {

      Console.WriteLine('익명 메서드 호출");

    });

  thread.Start();
  thread.Join();

}

Thread 생성자에 직접 delegate 예약어를 사용해 메서드의 코드를 전달한다.
이떄 delegate 예약어의 괄호에는 원래의 델리게이트 형식에서
필요로 했던 매개변수를 전달해야한다.

예) 람다식 구문 사용

Thread thread = new Thread((obj) =>
{
  Console.WriteLine('익명 메서드 호출");
}

delegate 예약어를 생략하는 동시에 인자의 타입을 굳이
개발자가 명시하지 않아도 되게 만들었다.
```

### 4. 닷넷에서의 데이터 타입은 값 타입과 참조 타입으로 구분되어 힙영역과 스택영역에 데이터를 나누어서 저장하게 됩니다. 때문에 빈번하게 박싱/언박싱이 일어나게 됩니다. 그렇다면 박싱 언박싱은 무엇인지 그리고 성능에 있어서 어떤 영향을 미치는지 설명해주세요. 난이도 ★★★☆☆

```
박싱(Boxing) : 값 형식을 참조 형식으로 변환
스택에 있는 데이터가 힙으로 복사
암시적 형변환 가능

언박싱(unboxing) : 참조 형식을 값 형식으로 변환
힙에 있는 데이터가 스택으로 복사
명시적 형변환 필요

박싱한 객체에 대해서만 언박싱이 가능
박싱할 때의 값 형식의 타입을 준수

예)
short i= 123; // 값 형식
object o = i; //박싱
int j = (int) o; //int 로 언박싱 불가능
```

### 5. 객체를 만들 때 메모리 해제를 위해서 일반적으로 IDisposable 인터페이스를 상속받아서 처리하게 되는 경우가 많습니다. 닷넷에서의 소멸자는 Dispose(), Finalize()가 존재하는데 이 두 가지의 차이점은 무엇인지 기술해주세요. 난이도 ★★★★☆

```
마이크로소프트는 자원 해제가 필요하다고 판단되는 모든 객체는
개발자로 하여금 IDisposable 인터페이스를 상속받도록 권장하고 있다.

IDisposable 인터페이스가 구현돼 있다면 해당 객체의 사용이 끝나면
Dispose 메서드를 호출해야 한다는 것을 직관적으로 알 수 있다.

Dispose하기 전에 예외가 발생한다면 Dispose메서드가 호출되지 않으므로
정상적으로 자원 회수가 안된다.

따라서 보통 try/finally를 이용해 Dispose를 호출하는 것이 관례다.
```
